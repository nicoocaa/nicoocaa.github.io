<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Documentation C# - Détails Complets</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            background-color: #f4f4f4;
            margin: 0;
            padding: 0;
        }
        header {
            background: #333;
            color: #fff;
            padding: 10px 0;
            text-align: center;
        }
        section {
            padding: 20px;
            margin: 10px;
            background: #fff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        h1, h2 {
            color: #333;
        }
        code {
            background-color: #f5f5f5;
            padding: 5px;
            border-radius: 3px;
        }
        pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 3px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
    </style>
</head>
<body>

<header>
    <h1>Documentation C# : Détails Complets</h1>
</header>

<section>
    <h2>1. Introduction au C#</h2>
    <p>C# est un langage de programmation moderne, conçu pour créer des applications sur la plateforme .NET. Ce langage puissant est orienté objet et prend en charge de nombreux concepts avancés.</p>

    <h3>1.1. Syntaxe de base</h3>
    <p>Voici un programme simple qui affiche "Hello, World!" :</p>
    <pre><code>using System;

class Program
{
    static void Main()
    {
        Console.WriteLine("Hello, World!");
    }
}</code></pre>

    <p>C# utilise des espaces de noms (namespace) pour organiser les classes. Le mot-clé <code>using</code> inclut ces espaces dans votre programme.</p>
</section>

<section>
    <h2>2. Variables et Types de données</h2>
    <p>C# est un langage typé statiquement, ce qui signifie que les types des variables doivent être définis lors de la déclaration.</p>

    <h3>2.1. Types primitifs</h3>
    <pre><code>int number = 10; // Entier
string text = "Hello"; // Chaîne de caractères
double price = 9.99; // Nombre à virgule flottante
bool isActive = true; // Booléen</code></pre>

    <h3>2.2. Types complexes</h3>
    <p>Les types complexes sont les classes, structures, tableaux, etc.</p>
    <pre><code>class Person
{
    public string Name;
    public int Age;
}</code></pre>

    <h3>2.3. Tableaux</h3>
    <pre><code>int[] numbers = { 1, 2, 3, 4, 5 };
Console.WriteLine(numbers[0]); // Accéder au premier élément</code></pre>
</section>

<section>
    <h2>3. Structures de contrôle</h2>
    <h3>3.1. Conditionnelles</h3>
    <pre><code>int age = 20;
if (age >= 18)
{
    Console.WriteLine("Vous êtes majeur.");
}
else
{
    Console.WriteLine("Vous êtes mineur.");
}</code></pre>

    <h3>3.2. Boucles</h3>
    <h4>&#9654; <code>for</code></h4>
    <pre><code>for (int i = 0; i < 5; i++)
{
    Console.WriteLine(i);
}</code></pre>

    <h4>&#9654; <code>while</code></h4>
    <pre><code>int i = 0;
while (i < 5)
{
    Console.WriteLine(i);
    i++;
}</code></pre>

    <h4>&#9654; <code>foreach</code></h4>
    <pre><code>int[] numbers = {1, 2, 3, 4, 5};
foreach (var number in numbers)
{
    Console.WriteLine(number);
}</code></pre>
</section>

<section>
    <h2>4. Classes et Objets</h2>
    <h3>4.1. Déclaration d'une classe</h3>
    <pre><code>class Person
{
    public string Name;
    public int Age;

    public void Greet()
    {
        Console.WriteLine("Hello, my name is " + Name);
    }
}</code></pre>

    <h3>4.2. Constructeurs</h3>
    <pre><code>class Person
{
    public string Name;
    public int Age;

    public Person(string name, int age)
    {
        Name = name;
        Age = age;
    }
}</code></pre>

    <h3>4.3. Création d'un objet</h3>
    <pre><code>Person person1 = new Person("Alice", 25);
person1.Greet();  // Affiche "Hello, my name is Alice"</code></pre>
</section>

<section>
    <h2>5. Encapsulation</h2>
    <p>L'encapsulation consiste à protéger les données en les rendant privées et en les manipulant via des méthodes publiques.</p>

    <h3>5.1. Propriétés</h3>
    <pre><code>class Person
{
    private int age;

    public int Age
    {
        get { return age; }
        set
        {
            if (value > 0)
                age = value;
            else
                Console.WriteLine("Age must be positive.");
        }
    }
}</code></pre>

    <h3>5.2. Utilisation des propriétés</h3>
    <pre><code>Person person1 = new Person();
person1.Age = 30;  // Utilisation du setter
Console.WriteLine(person1.Age);  // Utilisation du getter</code></pre>
</section>

<section>
    <h2>6. Héritage</h2>
    <p>L'héritage permet à une classe d'hériter des propriétés et des méthodes d'une autre classe.</p>

    <h3>6.1. Exemple d'héritage simple</h3>
    <pre><code>class Animal
{
    public string Name;
    public void Speak()
    {
        Console.WriteLine("Animal speaks");
    }
}

class Dog : Animal
{
    public void Bark()
    {
        Console.WriteLine("Woof!");
    }
}</code></pre>

    <h3>6.2. Accéder aux membres de la classe parente avec <code>base</code></h3>
    <pre><code>class Dog : Animal
{
    public void DisplayInfo()
    {
        Console.WriteLine("Name: " + base.Name); // Accède à Name via la classe parente
    }
}</code></pre>
</section>

<section>
    <h2>7. Polymorphisme</h2>
    <p>Le polymorphisme permet d'utiliser des objets de types différents via une interface ou une classe parente.</p>

    <h3>7.1. Surcharge de méthodes</h3>
    <pre><code>class Calculator
{
    public int Add(int a, int b)
    {
        return a + b;
    }

    public double Add(double a, double b)
    {
        return a + b;
    }
}</code></pre>
</section>

<section>
    <h2>8. Interfaces</h2>
    <p>Les interfaces permettent de définir des contrats que les classes doivent suivre.</p>

    <h3>8.1. Définir une interface</h3>
    <pre><code>interface IShape
{
    double CalculateArea();
}

class Circle : IShape
{
    public double Radius;

    public double CalculateArea()
    {
        return Math.PI * Radius * Radius;
    }
}</code></pre>
</section>

<section>
    <h2>9. Délégués et événements</h2>
    <p>Les délégués sont des pointeurs vers des méthodes, et les événements permettent de déclencher des actions lorsque des conditions spécifiques sont remplies.</p>

    <h3>9.1. Définir un délégué</h3>
    <pre><code>delegate void Notify(string message);

class Process
{
    public Notify OnComplete;

    public void StartProcess()
    {
        // Simuler un traitement
        OnComplete?.Invoke("Process Completed");
    }
}</code></pre>
</section>

<section>
    <h2>10. Gestion des erreurs</h2>
    <p>Les exceptions permettent de gérer les erreurs de manière structurée dans le programme.</p>

    <h3>10.1. Exemple de bloc try-catch</h3>
    <pre><code>try
{
    int result = 10 / 0;  // Provoque une division par zéro
}
catch (DivideByZeroException ex)
{
    Console.WriteLine("Erreur: " + ex.Message);
}</code></pre>
</section>

    <section id="memory-management">
    <h2>Gestion de la mémoire (Garbage Collection)</h2>
    <p>C# utilise un ramasse-miettes (Garbage Collector - GC) pour gérer la mémoire. Il libère automatiquement la mémoire des objets qui ne sont plus utilisés.</p>
    <pre><code>GC.Collect(); // Force la collecte des objets non utilisés</code></pre>
</section>

<section id="value-vs-reference-types">
    <h2>Types Valeur vs Types Référence</h2>
    <p>Les types de valeur (comme <code>int</code>, <code>double</code>, <code>struct</code>) sont stockés dans la pile, tandis que les types de référence (comme <code>class</code>, <code>string</code>) sont stockés dans le tas.</p>
    <pre><code>// Exemple avec un type de valeur
int a = 10;
int b = a;  // b est une copie indépendante

// Exemple avec un type de référence
class Person
{
    public string Name;
}

Person p1 = new Person();
p1.Name = "Alice";
Person p2 = p1;  // p2 et p1 pointent vers le même objet</code></pre>
</section>

<section id="nullable-types">
    <h2>Nullable Types</h2>
    <p>Les types nullable permettent aux types de valeur de représenter une valeur <code>null</code>, ce qui est utile pour indiquer l'absence de valeur.</p>
    <pre><code>int? nullableInt = null; // Nullable int
if (nullableInt.HasValue)
{
    Console.WriteLine(nullableInt.Value);
}
else
{
    Console.WriteLine("Pas de valeur");
}</code></pre>
</section>

<section id="linq">
    <h2>LINQ (Language Integrated Query)</h2>
    <p>LINQ permet de manipuler des collections, des bases de données ou même des fichiers XML de manière déclarative.</p>
    <pre><code>int[] numbers = { 1, 2, 3, 4, 5 };
var evenNumbers = from n in numbers
                  where n % 2 == 0
                  select n;

foreach (var num in evenNumbers)
{
    Console.WriteLine(num); // Affiche les nombres pairs
}</code></pre>
</section>

<section id="async-await">
    <h2>Async/Await et les tâches asynchrones</h2>
    <p>Les mots-clés <code>async</code> et <code>await</code> permettent de gérer les opérations asynchrones sans bloquer l'interface utilisateur.</p>
    <pre><code>async Task<string> GetDataAsync()
{
    await Task.Delay(1000); // Simulation d'une opération asynchrone
    return "Données récupérées";
}

public async void Main()
{
    string data = await GetDataAsync();
    Console.WriteLine(data);
}</code></pre>
</section>

<section id="delegates-events-lambdas">
    <h2>Delegates, Events et Lambdas</h2>
    <p>Les délégués sont des pointeurs vers des méthodes, et les événements permettent de réagir à des actions spécifiques.</p>
    <pre><code>delegate void Notify(string message);

class Process
{
    public event Notify OnComplete;

    public void StartProcess()
    {
        OnComplete?.Invoke("Process Completed");
    }
}

public class Program
{
    static void Main()
    {
        Process process = new Process();
        process.OnComplete += message => Console.WriteLine(message); // Lambda pour écouter l'événement
        process.StartProcess();
    }
}</code></pre>
</section>

<section id="attributes-reflection">
    <h2>Attributs et Réflexion</h2>
    <p>Les attributs ajoutent des métadonnées aux éléments de code, et la réflexion permet d'examiner ces métadonnées pendant l'exécution.</p>
    <pre><code>[AttributeUsage(AttributeTargets.Class)]
class MyCustomAttribute : Attribute
{
    public string Description { get; set; }
}

[MyCustomAttribute(Description = "Ceci est une classe spéciale.")]
class SpecialClass
{
    // Code de la classe
}</code></pre>
</section>

<section id="file-io">
    <h2>Gestion des fichiers (IO)</h2>
    <p>C# permet de lire et d'écrire dans des fichiers avec les classes du namespace <code>System.IO</code>.</p>
    <pre><code>using System.IO;

string path = "example.txt";

// Lecture d'un fichier
string content = File.ReadAllText(path);
Console.WriteLine(content);

// Écriture dans un fichier
File.WriteAllText(path, "Hello, World!");</code></pre>
</section>

<section id="generics">
    <h2>Génériques (Generics)</h2>
    <p>Les génériques permettent de créer des classes, des méthodes ou des interfaces qui fonctionnent avec des types spécifiés au moment de l'utilisation.</p>
    <pre><code>class Box<T>
{
    public T Value { get; set; }

    public Box(T value)
    {
        Value = value;
    }
}

var intBox = new Box<int>(123);
Console.WriteLine(intBox.Value); // Affiche 123</code></pre>
</section>

<section id="reflection-attributes">
    <h2>Attributes et Reflection</h2>
    <p>Les attributs sont utilisés pour ajouter des métadonnées aux classes et à d'autres éléments de code. La réflexion permet d'examiner et d'utiliser ces attributs pendant l'exécution.</p>
    <pre><code>[AttributeUsage(AttributeTargets.Class)]
public class InfoAttribute : Attribute
{
    public string Author { get; }
    public InfoAttribute(string author)
    {
        Author = author;
    }
}

[Info("John Doe")]
public class MyClass { }</code></pre>
</section>

     <section id="bases">
        <h2>Bases de C#</h2>
        <h3>Premiers pas avec C#</h3>
        <pre><code>// Exemple : Hello World
using System;

class Program
{
    static void Main()
    {
        Console.WriteLine("Hello, World!");
    }
}</code></pre>
        <h3>Variables et types</h3>
        <ul>
            <li>int, double, float</li>
            <li>string, char</li>
            <li>bool</li>
        </ul>
        <pre><code>// Exemple de déclaration de variables
int age = 25;
string nom = "Jean";
bool estActif = true;</code></pre>
        <h3>Structures de contrôle</h3>
        <pre><code>// Exemple de boucle for
for (int i = 0; i < 5; i++)
{
    Console.WriteLine(i);
}

// Exemple de condition if-else
if (age > 18)
{
    Console.WriteLine("Adulte");
}
else
{
    Console.WriteLine("Mineur");
}</code></pre>
    </section>
    <section id="oop">
        <h2>Programmation Orientée Objet (POO)</h2>
        <h3>Classes et objets</h3>
        <pre><code>// Exemple de classe et objet
class Personne
{
    public string Nom { get; set; }
    public int Age { get; set; }
    
    public void SePresenter()
    {
        Console.WriteLine($"Je m'appelle {Nom} et j'ai {Age} ans.");
    }
}

// Utilisation
Personne p = new Personne { Nom = "Alice", Age = 30 };
p.SePresenter();</code></pre>
    </section>
    <section id="heritage">
        <h2>Héritage</h2>
        <p>L'héritage permet à une classe d'hériter des propriétés et méthodes d'une autre classe.</p>
        <pre><code>// Exemple d'héritage
class Animal
{
    public void Manger()
    {
        Console.WriteLine("Je mange.");
    }
}

class Chien : Animal
{
    public void Aboyer()
    {
        Console.WriteLine("Woof!");
    }
}

// Utilisation
Chien monChien = new Chien();
monChien.Manger();
monChien.Aboyer();</code></pre>
    </section>
    <section id="interfaces">
        <h2>Interfaces</h2>
        <p>Les interfaces définissent un contrat que les classes doivent respecter.</p>
        <pre><code>// Exemple d'interface
interface IAnimal
{
    void SeDeplacer();
}

class Oiseau : IAnimal
{
    public void SeDeplacer()
    {
        Console.WriteLine("Je vole.");
    }
}

// Utilisation
IAnimal oiseau = new Oiseau();
oiseau.SeDeplacer();</code></pre>
    </section>
    <section id="avances">
        <h2>Concepts avancés</h2>
        <h3>Gestion des exceptions</h3>
        <pre><code>// Exemple de gestion des exceptions
try
{
    int resultat = 10 / 0;
}
catch (DivideByZeroException ex)
{
    Console.WriteLine("Erreur : Division par zéro.");
}</code></pre>
        <h3>LINQ</h3>
        <pre><code>// Exemple de LINQ
using System;
using System.Linq;

int[] nombres = { 1, 2, 3, 4, 5 };
var pairs = nombres.Where(n => n % 2 == 0);

foreach (var nombre in pairs)
{
    Console.WriteLine(nombre);
}</code></pre>
    </section>

</body>
</html>
