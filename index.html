<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Documentation C# - Détails Complets</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            background-color: #f4f4f4;
            margin: 0;
            padding: 0;
        }
        header {
            background: #333;
            color: #fff;
            padding: 10px 0;
            text-align: center;
        }
        section {
            padding: 20px;
            margin: 10px;
            background: #fff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        h1, h2 {
            color: #333;
        }
        code {
            background-color: #f5f5f5;
            padding: 5px;
            border-radius: 3px;
        }
        pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 3px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
    </style>
</head>
<body>

<header>
    <h1>Documentation C# : Détails Complets</h1>
</header>

<section>
    <h2>1. Introduction au C#</h2>
    <p>C# est un langage de programmation moderne, conçu pour créer des applications sur la plateforme .NET. Ce langage puissant est orienté objet et prend en charge de nombreux concepts avancés.</p>

    <h3>1.1. Syntaxe de base</h3>
    <p>Voici un programme simple qui affiche "Hello, World!" :</p>
    <pre><code>using System;

class Program
{
    static void Main()
    {
        Console.WriteLine("Hello, World!");
    }
}</code></pre>

    <p>C# utilise des espaces de noms (namespace) pour organiser les classes. Le mot-clé <code>using</code> inclut ces espaces dans votre programme.</p>
</section>

<section>
    <h2>2. Variables et Types de données</h2>
    <p>C# est un langage typé statiquement, ce qui signifie que les types des variables doivent être définis lors de la déclaration.</p>

    <h3>2.1. Types primitifs</h3>
    <pre><code>int number = 10; // Entier
string text = "Hello"; // Chaîne de caractères
double price = 9.99; // Nombre à virgule flottante
bool isActive = true; // Booléen</code></pre>

    <h3>2.2. Types complexes</h3>
    <p>Les types complexes sont les classes, structures, tableaux, etc.</p>
    <pre><code>class Person
{
    public string Name;
    public int Age;
}</code></pre>

    <h3>2.3. Tableaux</h3>
    <pre><code>int[] numbers = { 1, 2, 3, 4, 5 };
Console.WriteLine(numbers[0]); // Accéder au premier élément</code></pre>
</section>

<section>
    <h2>3. Structures de contrôle</h2>
    <h3>3.1. Conditionnelles</h3>
    <pre><code>int age = 20;
if (age >= 18)
{
    Console.WriteLine("Vous êtes majeur.");
}
else
{
    Console.WriteLine("Vous êtes mineur.");
}</code></pre>

    <h3>3.2. Boucles</h3>
    <h4>&#9654; <code>for</code></h4>
    <pre><code>for (int i = 0; i < 5; i++)
{
    Console.WriteLine(i);
}</code></pre>

    <h4>&#9654; <code>while</code></h4>
    <pre><code>int i = 0;
while (i < 5)
{
    Console.WriteLine(i);
    i++;
}</code></pre>

    <h4>&#9654; <code>foreach</code></h4>
    <pre><code>int[] numbers = {1, 2, 3, 4, 5};
foreach (var number in numbers)
{
    Console.WriteLine(number);
}</code></pre>
</section>

<section>
    <h2>4. Classes et Objets</h2>
    <h3>4.1. Déclaration d'une classe</h3>
    <pre><code>class Person
{
    public string Name;
    public int Age;

    public void Greet()
    {
        Console.WriteLine("Hello, my name is " + Name);
    }
}</code></pre>

    <h3>4.2. Constructeurs</h3>
    <pre><code>class Person
{
    public string Name;
    public int Age;

    public Person(string name, int age)
    {
        Name = name;
        Age = age;
    }
}</code></pre>

    <h3>4.3. Création d'un objet</h3>
    <pre><code>Person person1 = new Person("Alice", 25);
person1.Greet();  // Affiche "Hello, my name is Alice"</code></pre>
</section>

<section>
    <h2>5. Encapsulation</h2>
    <p>L'encapsulation consiste à protéger les données en les rendant privées et en les manipulant via des méthodes publiques.</p>

    <h3>5.1. Propriétés</h3>
    <pre><code>class Person
{
    private int age;

    public int Age
    {
        get { return age; }
        set
        {
            if (value > 0)
                age = value;
            else
                Console.WriteLine("Age must be positive.");
        }
    }
}</code></pre>

    <h3>5.2. Utilisation des propriétés</h3>
    <pre><code>Person person1 = new Person();
person1.Age = 30;  // Utilisation du setter
Console.WriteLine(person1.Age);  // Utilisation du getter</code></pre>
</section>

<section>
    <h2>6. Héritage</h2>
    <p>L'héritage permet à une classe d'hériter des propriétés et des méthodes d'une autre classe.</p>

    <h3>6.1. Exemple d'héritage simple</h3>
    <pre><code>class Animal
{
    public string Name;
    public void Speak()
    {
        Console.WriteLine("Animal speaks");
    }
}

class Dog : Animal
{
    public void Bark()
    {
        Console.WriteLine("Woof!");
    }
}</code></pre>

    <h3>6.2. Accéder aux membres de la classe parente avec <code>base</code></h3>
    <pre><code>class Dog : Animal
{
    public void DisplayInfo()
    {
        Console.WriteLine("Name: " + base.Name); // Accède à Name via la classe parente
    }
}</code></pre>
</section>

<section>
    <h2>7. Polymorphisme</h2>
    <p>Le polymorphisme permet d'utiliser des objets de types différents via une interface ou une classe parente.</p>

    <h3>7.1. Surcharge de méthodes</h3>
    <pre><code>class Calculator
{
    public int Add(int a, int b)
    {
        return a + b;
    }

    public double Add(double a, double b)
    {
        return a + b;
    }
}</code></pre>
</section>

<section>
    <h2>8. Interfaces</h2>
    <p>Les interfaces permettent de définir des contrats que les classes doivent suivre.</p>

    <h3>8.1. Définir une interface</h3>
    <pre><code>interface IShape
{
    double CalculateArea();
}

class Circle : IShape
{
    public double Radius;

    public double CalculateArea()
    {
        return Math.PI * Radius * Radius;
    }
}</code></pre>
</section>

<section>
    <h2>9. Délégués et événements</h2>
    <p>Les délégués sont des pointeurs vers des méthodes, et les événements permettent de déclencher des actions lorsque des conditions spécifiques sont remplies.</p>

    <h3>9.1. Définir un délégué</h3>
    <pre><code>delegate void Notify(string message);

class Process
{
    public Notify OnComplete;

    public void StartProcess()
    {
        // Simuler un traitement
        OnComplete?.Invoke("Process Completed");
    }
}</code></pre>
</section>

<section>
    <h2>10. Gestion des erreurs</h2>
    <p>Les exceptions permettent de gérer les erreurs de manière structurée dans le programme.</p>

    <h3>10.1. Exemple de bloc try-catch</h3>
    <pre><code>try
{
    int result = 10 / 0;  // Provoque une division par zéro
}
catch (DivideByZeroException ex)
{
    Console.WriteLine("Erreur: " + ex.Message);
}</code></pre>
</section>

</body>
</html>
